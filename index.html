<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <style type="text/css">
body {
  margin: 0;
  padding: 0;
}

* {
  box-sizing: border-box;
}

body, input, textarea {
  font-family: 'Courier', monospace;
  font-size: 13px;
}

#container {
  position: absolute;
  width: 1024px;
  height: 600px;
  background-color: #ddb;
}

#editor-pane {
  background-color: #e47;
  position: absolute;
  top: 0;
  left: 0;
  width: 512px;
  height: 600px;
}

#cli-pane {
  background-color: #ddb;
  position: absolute;
  top: 0;
  right: 0;
  width: 512px;
  height: 600px;
}

#editor {
  height: 600px;
  width: 512px;
  border: 1px solid gray;
  resize: none;
}

.ace_gutter-cell.ace_warning,
.ace_gutter-cell.ace_info,
.ace_gutter-cell.ace_error {
  background-color: #fff0b0;
}

input#import {
  position: absolute;
  top: -999px;
}

.inset-border {
  border-top: 3px solid gray;
  border-left: 3px solid gray;
  border-right: 3px solid lightgray;
  border-bottom: 3px solid lightgray;
}

#log {
  position: absolute;
  height: 550px;
  width: 512px;
  background-color: #aaa;
}

#log-items {
  position: absolute;
  bottom: 0;
  width: 506px;
  max-height: 550px;
  overflow-y: auto;
  overflow-x: hidden;
}

blockquote {
  margin: 0;
  padding: 6px;
  border-left: 3px solid #aac;
  background: #dde;
}

blockquote .attribution {
  color: #88a;
  font-size: 12px;
  padding-bottom: 3px;
}

#terminal {
  position: absolute;
  top: 480px;
  width: 512px;
  height: 52px;
  background-color: black;
  color: goldenrod;
  padding-left: 5px;
  white-space: pre-line;
  line-height: 22px;
}

input#command-line {
  border-radius: 8px;
  position: absolute;
  top: 556px;
  left: 6px;
  height: 38px;
  width: 500px;
  color: #fd6;
  background: black;
  padding: 6px;
  line-height: 20px;
}

.page {
  white-space: pre-wrap;
  overflow: hidden;
  margin: 5px;
  padding: 5px;
  border-radius: 2px;
  width: 482px;
  background-color: #f0f0f0;
  box-shadow: 0 1px 1px #444;
  opacity: 0.7;
  transition: opacity 200ms;
}

.page:last-child {
  margin-bottom: 0;
  border-bottom-left-radius: 0;
  border-bottom-right-radius: 0;
  opacity: 1;
}

.page .title {
  color: #0a0;
  border-bottom: 1px solid #ddd;
  margin-bottom: 3px;
  padding-bottom: 3px;
}

.new-messages {
  margin: 6px 0;
  border-bottom: 1px solid #ddd;
}

    </style>
  </head>
  <body>
    <div id="container">
      <div id="editor-pane">
        <div id="editor"></div>
      </div>
      <input type="file" id="import">
      <div id="cli-pane">
        <div id="log" class="inset-border">
          <div id="log-items">
          </div>
        </div>
        <input id="command-line" class="inset-border" type="text">
      </div>
    </div>

    <script type="text/javascript" src="./ace.js"></script>
    <script type="text/javascript" src="./fileSaver.js"></script>
    <script type="text/javascript" src="./log.js"></script>
    <script type="text/javascript">

navigator.serviceWorker.register('./caching-service-worker.js', {
    scope: './'
  }).then(function (reg) {
    console.debug('Service Worker registered successfully!')
  }).catch(function (err) {
    console.debug('Service Worker failed to register', err)
  })

    </script>
    <script type="text/javascript">

const cliInput = document.getElementById('command-line')
const importFileInput = document.getElementById('import')
const editor = ace.edit('editor')

const CANCELED_MSG = 'Canceled by ESC.'

let validTokensForInput = null

editor.setTheme("ace/theme/xcode");
editor.getSession().setMode("ace/mode/javascript");
editor.getSession().setUseSoftTabs(false)
editor.setValue(localStorage['file'] || '')
editor.clearSelection()
editor.addEventListener('blur', function() {
  localStorage['file'] = editor.getValue()
  initUserProgram()
})

editor.getSession().on('changeMode', updateLinterOptions)

cliInput.addEventListener('keydown', function(event) {
  let input = cliInput.value
  if (event.key === 'Enter') {
    event.preventDefault()

    if (input.charAt(0) === ';') {
      // if the line starts with the magic character ';',
      // eval it as JavaScript
      evalAndPrintResult(input.slice(1))
    } else if (programState === 'waitingForInput') {
      programState = 'running'
      program.next(input)
    }

    cliInput.value = ''
  } else if (event.key === 'Escape') {
    event.preventDefault()
    if (programState !== 'running') {
      programState = 'running'
      program.throw(CANCELED_MSG)
      cliInput.value = ''
    }
  }
})

function exportToFile() {
  var blob = new Blob([localStorage['file']], {type: "text/plain;charset=utf-8"});
  saveAs(blob, 'save.txt')
}

importFileInput.addEventListener('change', function(event) {
  let input = event.target
  let reader = new FileReader()
  reader.addEventListener('load', handleFileContents)
  reader.readAsText(input.files[0])

  function handleFileContents() {
    let text = reader.result
    localStorage['file'] = text
    editor.setValue(text)
  }
})

////////////////////////////////////////////////////////////
// API FOR USER PROGRAMS
////////////////////////////////////////////////////////////

function sleep(seconds) {
  assertYielded('tried to sleep')
  flushLog()
  programState = 'sleeping'
  setTimeout(function() {
    // Sleep can be interrupted by the user, so if we're
    // not sleeping when the timer goes off, do nothing.
    if (programState !== 'sleeping') return
    programState = 'running'
    program.next()
  }, seconds * 1000)
}

function save() {
  localStorage['state'] = globalsAsJson()
}

Object.defineProperty(window, 'help', {
  get: function() {
    let functions = Object.keys(userGlobalNames)
      .filter(name => typeof window[name] === 'function')
      .sort()

    let variables = Object.keys(userGlobalNames)
      .filter(name => typeof window[name] !== 'function')
      .sort()

    let output = 'AVAILABLE FUNCTIONS\n\n'
      + functions.map(indent).join('\n')
      + '\n\nAVAILABLE VARIABLES\n\n'
      + variables.map(indent).join('\n')
    inform(output)

    function indent(s) {
      return '  ' + s
    }
  }
})

let userGlobalNames = {}
function initializeGlobals(initialValues) {
  for (let key in userGlobalNames) {
    if (!(key in initialValues)) {
      // key has been removed from the program
      delete window[key]
      delete userGlobalNames[key]
    }
  }

  for (let key in initialValues) {
    // if the type of the variable has changed, we need to
    // reinitialize it. Reinitialize functions too, since
    // they should be stateless and the programmer may have
    // changed the function definition
    if (typeof initialValues[key] === 'function'
      || !sameType(window[key], initialValues[key])) {
      window[key] = initialValues[key]
      userGlobalNames[key] = true
    }
  }

  function sameType(a, b) {
    var toS = Object.prototype.toString
    return typeof a === typeof b && toS.call(a) === toS.call(b)
  }
}

// load the globals from the saved JSON
initializeGlobals(JSON.parse(localStorage['state'] || '{}'))

function getUserInput(prompt) {
  assertYielded('asked for user input')
  flushLog()

  let currentMode = modeStack[modeStack.length - 1]
  let promptPrefix = ' '
  promptPrefix += currentMode ? currentMode + ': ' : ''

  cliInput.placeholder = promptPrefix + prompt
  cliInput.focus()
  programState = 'waitingForInput'
}

function assertYielded(request) {
  if (programState !== 'running') {
    throw 'You ' + request
      + ',\nbut it looks like the program is currently '
      + programState
      + '.\nThis probably means you forgot to `yield` '
      + 'earlier in your program.'
  }
}

function *getUserInputIn(validTokens, prompt) {
  if (typeof validTokens === 'string') {
    validTokens = validTokens.split('')
  }

  if (validTokens) {
    validTokensForInput = validTokens
  }

  getInput: for (;;) {

  let answer = yield getUserInput(prompt)
  if (!validTokens.includes(answer)) {
    alert('Please enter ' + conjunctivePhrase(validTokens))
    continue getInput
  }

  return answer
}}

function addHelpText(fn, text) {
  Object.defineProperty(fn, 'help', {
    get: function() {
      inform(text)
    }
  })
}

////////////////////////////////////////////////////////////
// UTILITY FUNCTIONS
////////////////////////////////////////////////////////////

function globalsAsJson() {
  let forJson = {}
  for (let key in userGlobalNames) {
    forJson[key] = window[key]
  }
  return JSON.stringify(forJson)
}

function conjunctivePhrase(list) {
  if (list.length <= 2) {
    return list.join(' or ')
  } else {
    return list[0] + ', ' + conjunctivePhrase(list.slice(1))
  }
}

const modeStack = []

function pushMode(functionName) {
  modeStack.push(functionName)
}

function popMode() {
  modeStack.pop()
}

function inspect(object) {
  if (typeof object === 'object') {
    return JSON.stringify(object, true, 2)
  }
  return '' + object
}

function updateLinterOptions() {
  let session = editor.getSession()
  if (session.$worker &&
      session.getMode().$id === "ace/mode/javascript") {
    session.$worker.send("setOptions", [{
      curly: true,
      eqeqeq: true,
      esversion: 6,
      funcscope: false,
      futurehostile: true,
      latedef: 'nofunc',
      nocomma: true,
      notypeof: true,
      varstmt: true,

      // relaxing options
      noyield: true,
    }])
  }
}

////////////////////////////////////////////////////////////
// START OF MAIN PROGRAM
////////////////////////////////////////////////////////////

// the program is a generator function that yields
// when it wants user input.
const program = Main__()
let programState = 'running'
program.next()

function *Main__() {
  logPushPage()

  inform('Loading MOSS, the Magical Operating System Simulacrum')
  cutLog()

  const ALLOWED_COMMANDS = [
    'help', 'js', 'load', 'run', 'save'
  ]

  yield sleep(0.4)

  mainLoop: while (true) {
    yield *mode(Shell)
  }

  function *Shell() {
    const HELP_TEXT = `AVAILABLE COMMANDS

help    Show this text again
js      Use JavaScript interactively
run     Run the function named 'Main' as an interactive
        program
save    Save your work to a file, e.g. to move it to
        another computer (work is saved in the browser
        on every change)
load    Load a file from your computer
`
    inform(HELP_TEXT)

    prompt: for (;;) {

    const PROMPT = 'Type a command and press ENTER'

    parseInput:
    switch (echo(yield *getUserInputIn(ALLOWED_COMMANDS, PROMPT))) {
      case 'help':
      inform(HELP_TEXT)
      break parseInput

      case 'js':
      yield *mode(JSPrompt)
      continue prompt

      case 'load':
      importFileInput.click()
      break parseInput

      case 'run':
      yield *RunProgram()
      continue prompt

      case 'save':
      exportToFile()
      break parseInput
    }

    cutLog()
  }}
}

function *JSPrompt() {
  // ensure that any functions we might want to call exist
  initUserProgram()

  ask('Enter some code and press ENTER (Press ESC to leave)')
  yield *repeatUntilCanceled(getAndRunScript)

  function *getAndRunScript() {
    cutLog()
    let script = echo(yield getUserInput())
    evalAndPrintResult(script)
  }
}

function evalAndPrintResult(js) {
  try {
    let result = eval(js)
    if (typeof result !== 'undefined') {
      inform(result)
    }
  } catch (e) {
    alert('' + e)
  }
}

function *RunProgram() {
  inform("Running your program starting from function `Main`")
  try {
    initUserProgram()
    // assume the code defines a function like
    // function *Main() { ... }
    yield *mode(window.Main)
  } catch (e) {
    alert(e)
    console.log(e)
  }

  save()
  inform("Program completed.")
  cutLog()
}

function initUserProgram() {
  let code = editor.getValue()

  code += ';' +
    functionNames(code)
      .map(putFunctionOnWindow)
      .join(';')

  new Function(code)()

  function putFunctionOnWindow(fname) {
    return `if (typeof ${fname} === 'function') window['${fname}'] = ${fname}`
  }

  function functionNames(code) {
    return code.match(/function\s*\*?\s*[a-zA-Z0-9_]+/g)
      .map(match => match.replace(/function\s*\*?\s*/, ''))
  }
}

function *mode(generator) {
  let error = null
  let returnVal
  assertYielded('tried to enter a new mode')
  flushLog()
  pushMode(generator.name)
  logPushPage(generator.name)

  try {
    returnVal = yield *generator()
  } catch (error) {
    logBadExceptions(error)
  }

  popMode()
  logPopPage()
  flushLogInBlockquote(generator.name)
  return returnVal
}

function *repeatUntilCanceled(generator) {
  try {
    while (true) yield *generator()
  } catch (error) {
    logBadExceptions(error)
  }
}

function logBadExceptions(error) {
  if (error !== CANCELED_MSG) {
    alert(error)
    console.log(error)
  }
}
    </script>
  </body>
</html>

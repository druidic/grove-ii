<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <style type="text/css">
body {
  margin: 0;
  padding: 0;
}

* {
  box-sizing: border-box;
}

body, input, textarea {
  font-family: 'Courier', monospace;
  font-size: 13px;
}

#container {
  position: absolute;
  width: 960px;
  height: 600px;
  background-color: beige;
}

#editor-pane {
  background-color: #e47;
  position: absolute;
  top: 0;
  left: 0;
  width: 480px;
  height: 600px;
}

#cli-pane {
  background-color: #99ff88;
  position: absolute;
  top: 0;
  right: 0;
  width: 480px;
  height: 600px;
}

textarea#editor {
  height: 480px;
  width: 480px;
  border: 0;
  resize: none;
}

button#export {
  position: absolute;
  top: 490px;
  left: 10px;
}

input#import {
  position: absolute;
  top: 520px;
  left: 10px;
}

.inset-border {
  border-top: 3px solid gray;
  border-left: 3px solid gray;
  border-right: 3px solid lightgray;
  border-bottom: 3px solid lightgray;
}

#log {
  position: absolute;
  height: 480px;
  width: 480px;
  background-color: #aaa;
}

#log-items {
  position: absolute;
  bottom: 0;
  width: 474px;
  max-height: 474px;
  overflow-y: auto;
  overflow-x: hidden;
}

blockquote {
  margin: 0;
  padding: 6px;
  border-left: 3px solid #aac;
  background: #dde;
}

blockquote .attribution {
  color: #88a;
  font-size: 12px;
  padding-bottom: 3px;
}

#terminal {
  position: absolute;
  top: 480px;
  width: 480px;
  height: 52px;
  background-color: black;
  color: goldenrod;
  padding-left: 5px;
  white-space: pre-line;
  line-height: 22px;
}

input#command-line {
  border: none;
  position: absolute;
  top: 0;
  left: 0;
  width: 474px;
  height: 47px;
  padding-top: 20px;
  color: #fd6;
  background: transparent;
  padding-left: 20.5px;
  line-height: 20px;
}

.page {
  white-space: pre;
  overflow: hidden;
  margin: 5px;
  padding: 5px;
  border-radius: 2px;
  width: 450px;
  background-color: #f0f0f0;
  box-shadow: 0 1px 1px #444;
  opacity: 0.7;
  transition: opacity 200ms;
}

.page:last-child {
  margin-bottom: 0;
  border-bottom-left-radius: 0;
  border-bottom-right-radius: 0;
  opacity: 1;
}

.page .title {
  color: #0a0;
  border-bottom: 1px solid #ddd;
  margin-bottom: 3px;
  padding-bottom: 3px;
}

    </style>
  </head>
  <body>
    <div id="container">
      <div id="editor-pane">
        <textarea id="editor"></textarea>
      </div>
      <button id="export">Export to File</button>
      <input type="file" id="import">
      <div id="cli-pane">
        <div id="log" class="inset-border">
          <div id="log-items">
          </div>
        </div>
        <div id="terminal" class="inset-border"><span id="breadcrumbs"></span>
          <input id="command-line" type="text">
        </div>
      </div>
    </div>

    <script type="text/javascript" src="./fileSaver.js"></script>
    <script type="text/javascript" src="./log.js"></script>
    <script type="text/javascript">

navigator.serviceWorker.register('./caching-service-worker.js', {
    scope: './'
  }).then(function (reg) {
    console.log('Service Worker registered successfully!')
  }).catch(function (err) {
    console.log('Service Worker failed to register', err)
  })

    </script>
    <script type="text/javascript">

const cliInput = document.getElementById('command-line')
const editor = document.getElementById('editor')
const breadcrumbs = document.getElementById('breadcrumbs')
const exportButton = document.getElementById('export')
const importFileInput = document.getElementById('import')

const CANCELED_MSG = 'Canceled by ESC.'

let validTokensForInput = null

editor.value = localStorage['file'] || ''

editor.addEventListener('blur', function() {
  localStorage['file'] = editor.value
  initUserProgram()
})

cliInput.addEventListener('keydown', function(event) {
  let input = cliInput.value
  if (event.key === 'Enter') {
    event.preventDefault()

    if (input.charAt(0) === ';') {
      // if the line starts with the magic character ';',
      // eval it as JavaScript
      evalAndPrintResult(input.slice(1))
    } else if (programState === 'waitingForInput') {
      programState = 'running'
      program.next(input)
    }

    cliInput.value = ''
  } else if (event.key === 'Escape') {
    event.preventDefault()
    if (programState !== 'running') {
      programState = 'running'
      program.throw(CANCELED_MSG)
      cliInput.value = ''
    }
  }
})

exportButton.addEventListener('click', exportToFile)

function exportToFile() {
  var blob = new Blob([localStorage['file']], {type: "text/plain;charset=utf-8"});
  saveAs(blob, 'save.txt')
}

importFileInput.addEventListener('change', function(event) {
  let input = event.target
  let reader = new FileReader()
  reader.addEventListener('load', handleFileContents)
  reader.readAsText(input.files[0])

  function handleFileContents() {
    let text = reader.result
    localStorage['file'] = text
    editor.value = text
  }
})

////////////////////////////////////////////////////////////
// API FOR USER PROGRAMS
////////////////////////////////////////////////////////////

function sleep(seconds) {
  assertYielded('tried to sleep')
  flushLog()
  programState = 'sleeping'
  setTimeout(function() {
    // Sleep can be interrupted by the user, so if we're
    // not sleeping when the timer goes off, do nothing.
    if (programState !== 'sleeping') return
    programState = 'running'
    program.next()
  }, seconds * 1000)
}

function save() {
  localStorage['state'] = globalsAsJson()
}

Object.defineProperty(window, 'help', {
  get: function() {
    let functions = Object.keys(userGlobalNames)
      .filter(name => typeof window[name] === 'function')
      .sort()

    let variables = Object.keys(userGlobalNames)
      .filter(name => typeof window[name] !== 'function')
      .sort()

    let output = 'AVAILABLE FUNCTIONS\n\n'
      + functions.map(indent).join('\n')
      + '\n\nAVAILABLE VARIABLES\n\n'
      + variables.map(indent).join('\n')
    inform(output)

    function indent(s) {
      return '  ' + s
    }
  }
})

let userGlobalNames = {}
function initializeGlobals(initialValues) {
  for (let key in userGlobalNames) {
    if (!(key in initialValues)) {
      // key has been removed from the program
      delete window[key]
      delete userGlobalNames[key]
    }
  }

  for (let key in initialValues) {
    // if the type of the variable has changed, we need to
    // reinitialize it. Reinitialize functions too, since
    // they should be stateless and the programmer may have
    // changed the function definition
    if (typeof initialValues[key] === 'function'
      || !sameType(window[key], initialValues[key])) {
      window[key] = initialValues[key]
      userGlobalNames[key] = true
    }
  }

  function sameType(a, b) {
    var toS = Object.prototype.toString
    return typeof a === typeof b && toS.call(a) === toS.call(b)
  }
}

// load the globals from the saved JSON
initializeGlobals(JSON.parse(localStorage['state'] || '{}'))

function getUserInput(prompt) {
  assertYielded('asked for user input')
  flushLog()

  breadcrumbs.innerText = (prompt || '') + '\n$'
  cliInput.focus()
  programState = 'waitingForInput'
}

function assertYielded(request) {
  if (programState !== 'running') {
    throw 'You ' + request
      + ',\nbut it looks like the program is currently '
      + programState
      + '.\nThis probably means you forgot to `yield` '
      + 'earlier in your program.'
  }
}

function *getUserInputIn(validTokens, prompt) {
  if (typeof validTokens === 'string') {
    validTokens = validTokens.split('')
  }

  if (validTokens) {
    validTokensForInput = validTokens
  }

  getInput: for (;;) {

  let answer = yield getUserInput(prompt)
  if (!validTokens.includes(answer)) {
    alert('Please enter ' + conjunctivePhrase(validTokens))
    continue getInput
  }

  return answer
}}

function addHelpText(fn, text) {
  Object.defineProperty(fn, 'help', {
    get: function() {
      inform(text)
    }
  })
}

////////////////////////////////////////////////////////////
// UTILITY FUNCTIONS
////////////////////////////////////////////////////////////

function globalsAsJson() {
  let forJson = {}
  for (let key in userGlobalNames) {
    forJson[key] = window[key]
  }
  return JSON.stringify(forJson)
}

function conjunctivePhrase(list) {
  if (list.length <= 2) {
    return list.join(' or ')
  } else {
    return list[0] + ', ' + conjunctivePhrase(list.slice(1))
  }
}

const modeStack = []

function pushMode(functionName) {
  modeStack.push(functionName)
  breadcrumbs.innerText = renderModeStack(modeStack) + '\n$'
}

function popMode() {
  modeStack.pop()
  breadcrumbs.innerText = renderModeStack(modeStack) + '\n$'
}

function renderModeStack(stack) {
  let renderableStack = stack
  let truncated = false
  while (totalLength(renderableStack) > 50) {
    truncated = true;
    renderableStack = renderableStack.slice(1)
  }
  return (truncated ? '... ' : '') +
    renderableStack
      .filter(a => a)
      .join(' > ')

  function totalLength(segments) {
    if (segments.length === 0) return 0

    return ' > '.length * segments.length - 1
      + segments.reduce((sum, seg) => sum + seg.length, 0)
  }
}

function inspect(object) {
  if (typeof object === 'object') {
    return JSON.stringify(object, true, 2)
  }
  return '' + object
}

////////////////////////////////////////////////////////////
// START OF MAIN PROGRAM
////////////////////////////////////////////////////////////

// the program is a generator function that yields
// when it wants user input.
const program = Main__()
let programState = 'running'
program.next()

function *Main__() {
  logPushPage()

  inform('Loading MOSS, the Magical Operating System Simulacrum')
  cutLog()
  yield sleep(0.6)

  const ALLOWED_COMMANDS = [
    'help', 'js', 'load', 'run', 'save'
  ]

  yield sleep(0.6)

  mainLoop: while (true) {
    yield *mode(Shell)
  }

  function *Shell() {
    const HELP_TEXT = `AVAILABLE COMMANDS

help    Show this text again
js      Use JavaScript interactively
run     Run the current program
save    Save your work to a file, e.g. to move it to
        another computer (work is saved in the browser
        on every change)
load    Load a file from your computer
`
    inform(HELP_TEXT)

    prompt: for (;;) {

    const PROMPT = 'Type a command and press ENTER'

    parseInput:
    switch (echo(yield *getUserInputIn(ALLOWED_COMMANDS, PROMPT))) {
      case 'help':
      inform(HELP_TEXT)
      break parseInput

      case 'js':
      yield *mode(JSPrompt)
      continue prompt

      case 'load':
      importFileInput.click()
      break parseInput

      case 'run':
      yield *RunProgram()
      continue prompt

      case 'save':
      exportToFile()
      break parseInput
    }

    cutLog()
  }}
}

function *JSPrompt() {
  // ensure that any functions we might want to call exist
  initUserProgram()

  ask('Enter some code and press ENTER (Press ESC to leave)')
  yield *repeatUntilCanceled(getAndRunScript)

  function *getAndRunScript() {
    cutLog()
    let script = echo(yield getUserInput())
    evalAndPrintResult(script)
  }
}

function evalAndPrintResult(js) {
  try {
    let result = eval(js)
    if (typeof result !== 'undefined') {
      inform(result)
    }
  } catch (e) {
    alert('' + e)
  }
}

function *RunProgram() {
  inform("Running your program starting from function `main`")
  initUserProgram()
  // assume the code defines a function like
  // program.main = function*() { ... }
  yield *mode(window.main)
  save()
  inform("Program completed.")
  cutLog()
}

function initUserProgram() {
  let code = editor.value
  new Function('program', code)(window)
}

function *mode(generator) {
  let error = null
  let returnVal
  assertYielded('tried to enter a new mode')
  flushLog()
  pushMode(generator.name)
  logPushPage(generator.name)

  try {
    returnVal = yield *generator()
  } catch (error) {
    logBadExceptions(error)
  }

  popMode()
  logPopPage()
  flushLogInBlockquote(generator.name)
  return returnVal
}

function *repeatUntilCanceled(generator) {
  try {
    while (true) yield *generator()
  } catch (error) {
    logBadExceptions(error)
  }
}

function logBadExceptions(error) {
  if (error !== CANCELED_MSG) {
    alert(error)
    console.log(error)
  }
}
    </script>
  </body>
</html>
